
# A* implementation

function euclidean_distance(pt_a::SVector{2,Float64}, pt_b::SVector{2,Float64})
    return sqrt((pt_a[1] - pt_b[1])^2 + (pt_a[2] - pt_b[2])^2)
end

function heuristic(pt_a, pt_b)
    return euclidean_distance(pt_a, pt_b)
end

function cost_function(map_segments, segment_id, neighbor_id)
    segment_pt = map_segments[segment_id].lane_boundaries[1].pt_a
    neighbor_pt = map_segments[neighbor_id].lane_boundaries[1].pt_a
    return euclidean_distance(segment_pt, neighbor_pt)
end

function a_star(map_segments, start_id, goal_id, spacing::Float64)
    start = map_segments[start_id].lane_boundaries[1].pt_a
    goal = map_segments[goal_id].lane_boundaries[1].pt_a

    open_set = PriorityQueue{Int, Float64}()
    enqueue!(open_set, start_id, 0.0)

    g_scores = Dict{Int, Float64}()
    g_scores[start_id] = 0.0

    f_scores = Dict{Int, Float64}()
    h_scores = Dict{Int, Float64}()

    h_scores[start_id] = heuristic(start, goal)
    f_scores[start_id] = h_scores[start_id]

    came_from = Dict{Int, Int}()

    while !isempty(open_set)
        current_id = dequeue!(open_set)

        if current_id == goal_id
            return reconstruct_path(came_from, goal_id, map_segments, spacing)
        end

        for neighbor_id in map_segments[current_id].children
            tentative_g_score = g_scores[current_id] + cost_function(map_segments, current_id, neighbor_id)

            if !(neighbor_id in keys(g_scores)) || tentative_g_score < g_scores[neighbor_id]
                came_from[neighbor_id] = current_id
                g_scores[neighbor_id] = tentative_g_score
                h_scores[neighbor_id] = heuristic(map_segments[neighbor_id].lane_boundaries[1].pt_a, goal)
                f_scores[neighbor_id] = g_scores[neighbor_id] + h_scores[neighbor_id]

                if !haskey(open_set, neighbor_id)
                    enqueue!(open_set, neighbor_id, f_scores[neighbor_id])
                end
            end
        end
    end

    return [] # Return an empty array if no path is found
end


# functions to obtain points on 2d plane for the path generated by A*

function rotate90(vec::SVector{2,Float64}, clockwise::Bool = true)
    if clockwise
        return SVector(-vec[2], vec[1])
    else
        return SVector(vec[2], -vec[1])
    end
end


function generate_points_on_lane_boundary(lane_boundary::LaneBoundary, spacing::Float64)
    pt_a = lane_boundary.pt_a
    pt_b = lane_boundary.pt_b
    curvature = lane_boundary.curvature

    points = []

    if isapprox(curvature, 0.0; atol=1e-6)
        # If the lane boundary is a straight line
        distance = norm(pt_b - pt_a)
        num_points = ceil(Int, distance / spacing)
        for i in 0:num_points
            point = pt_a + (pt_b - pt_a) * (i / num_points)
            push!(points, point)
        end
    else
        res = 0.5
        # If the lane boundary is a curved line
        points = generate_points_on_curved_lane_boundary(lane_boundary, res)
    end

    return points
end


function generate_points_on_curved_lane_boundary(lane_boundary::LaneBoundary, res::Float64)
    points = []

    pt_a = lane_boundary.pt_a
    pt_b = lane_boundary.pt_b
    curvature = lane_boundary.curvature

    if !isapprox(curvature, 0.0; atol=1e-6)
        rad = 1.0 / abs(curvature)
        dist = π * rad / 2.0
        N = (dist / res) |> ceil |> Int
        Δ = dist / N
        t = 0:Δ:dist .+ 0.01

        left = curvature > 0
        if left
            if sign(pt_b[1] - pt_a[1]) == sign(pt_b[2] - pt_a[2])
                center = pt_a + [0, pt_b[2] - pt_a[2]]
            else
                center = pt_a + [pt_b[1] - pt_a[1], 0]
            end
        else
            if sign(pt_b[1] - pt_a[1]) == sign(pt_b[2] - pt_a[2])
                center = pt_a + [pt_b[1] - pt_a[1], 0]
            else
                center = pt_a + [0, pt_b[2] - pt_a[2]]
            end
        end
        pt_a_rel = pt_a - center
        pt_b_rel = pt_b - center
        θ0 = atan(pt_a_rel[2], pt_a_rel[1])
        θT = atan(pt_b_rel[2], pt_b_rel[1]) 
        Δθ = mod((θT - θ0) + π, 2π) - π
        dθ = sign(Δθ) * π/2.0 / N

        segment_points = [SVector{2, Float64}(center[1] + rad * cos(θ0 + dθ * i), center[2] + rad * sin(θ0 + dθ * i)) for i in 0:N]
        append!(points, segment_points)
    end

    return points
end


function reconstruct_path(came_from, current_id, map_segments, spacing::Float64)
    path_ids = [current_id]
    while current_id in keys(came_from)
        current_id = came_from[current_id]
        push!(path_ids, current_id)
    end
    path_ids = reverse(path_ids)

    points = []
    for id in path_ids
        segment = map_segments[id]
        lane_boundary = segment.lane_boundaries[1]
        segment_points = generate_points_on_lane_boundary(lane_boundary, spacing)
        append!(points, segment_points[1:end-1])  # Excluding the last point to avoid duplication
    end
    push!(points, map_segments[last(path_ids)].lane_boundaries[1].pt_b)  # Adding the last point

    return points
end




# functions to create visualization for the path generated by A*

function plot_path(segment_maps)
    xs = Float64[]
    ys = Float64[]
    for segment in values(segment_maps)
        for lane_boundary in segment.lane_boundaries
            pt_a, pt_b = lane_boundary.pt_a, lane_boundary.pt_b
            push!(xs, pt_a[1], pt_b[1])
            push!(ys, pt_a[2], pt_b[2])
        end
    end

    # setting start and eng ids manually for now, will accept as function parameters later
    waypoints = a_star(segment_maps, 67, 4, 2.0)

    # Create a scatter plot for the lane boundaries
    plot = scatter(xs, ys, markersize=3, markercolor=:red, legend=false)

    # Create a color gradient
    num_waypoints = length(waypoints)
    colors = palette(:viridis, num_waypoints)

    # Add waypoints to the plot with gradually changing colors
    for (i, point) in enumerate(waypoints)
        scatter!(plot, [point[1]], [point[2]], markersize=3, markercolor=colors[i], legend=false)
    end

    xlims!(minimum(xs) - 10, maximum(xs) + 10)
    ylims!(minimum(ys) - 10, maximum(ys) + 10)
    savefig("seg_67_to_4.png")
end





# finds all curved segments

function curved_segments(map_segments)
    segments_with_curvature = []

    for (segment_id, segment) in map_segments
        for lane_boundary in segment.lane_boundaries
            if lane_boundary.curvature != 0
                push!(segments_with_curvature, segment_id)
                break
            end
        end
    end

    return segments_with_curvature
end